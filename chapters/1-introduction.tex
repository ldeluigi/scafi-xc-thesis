% ! TeX root = ../thesis-main.tex
%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

The importance of \acp{CAS} engineering is increasing along with the growing prevalence of large-scale cyber-physical systems, driven by the already pervasive \ac{IoT} and edge computing trends~\cite{collective,pervasive}.
%
\acp{CAS} are a particular subcategory of situated, distributed systems in which a collection of individuals, also called agents, exhibits a non-chaotic behavior characterized by \textit{self-*} properties, such as self-organization, self-healing, and self-configuration.
%
Many of the self-* properties cannot be derived from an individual perspective confined to the behavior of a single agent, but rather they are \textit{emergent} from the complex and dynamic network of interactions within the system and with the environment.
%
As a consequence, obtaining such properties requires a holistic approach to the design and programming of \acp{CAS}, which is not straightforward to achieve with traditional software engineering techniques.

Topologically, \acp{CAS} can be considered a subset of \acp{MAS}, and the programming of their behavior as a whole can be referred to as \textit{Macroprogramming}~\cite{macroprogramming-state-of-the-art}.
%
In the context of macroprogramming, a prominent paradigm is that of \textit{aggregate computing}, where a single program, called the aggregate program, defines the overall behavior of a network of devices or agents~\cite{macroprogramming-state-of-the-art}.
%
Aggregate computing provides benefits to development productivity thanks to four main factors~\cite{scafi}: the \textit{macro-level stance}, which abstracts over low-level details about the individual behavior of agents and their communication media, the \textit{compositionality}, promoting the creation of complex behavior by combining simpler ones, the \textit{formality}, allowing theoretical analyses and formal verification of its properties, and the \textit{practicality}, thanks to the availability of tools supporting programming and simulation of \acp{CAS}.

Among these tools, an in-depth analysis is dedicated to the \textit{ScaFi}, an aggregate programming framework that comprises an internal \ac{DSL} written in Scala 2 with supporting components for simulation, visualization, and execution of aggregate systems, based on the \ac{FC} formal language and computational model~\cite{scafi}.
%
Internal \acp{DSL} are distinguished from external \acp{DSL} by the fact that they are embedded in a host language, such as Scala, and that they exploit the flexibility of their host's syntax to resemble a different language even though they are implemented as libraries.

Recently, a new formal language and computational model called \ac{XC} has been proposed, extending the expressiveness of \ac{FC} while simplifying its set of primitive constructs~\cite{xc}.
%
In the meantime, Scala 2 has been succeeded by Scala 3, which introduces a relevant set of new features and improvements over its predecessor.
%
These two novelties have promoted the development of a new ScaFi, entirely redesigned to be formally based on \ac{XC} and to make the best use of its new host language, Scala 3.
%
That project is the main subject of this thesis.
%
Named \quotes{\this}, it has the ambition to \textit{scale}, meaning to grow with the demand of its user without losing its qualities, such as expressiveness, reusability, maintainability, readability, and performance.


\paragraph{Structure of the Thesis} The thesis is structured as follows.
%
In \Cref{chap:state-of-the-art}, the state of the art is reviewed, focusing on prominent frameworks and tools such as Protelis, FCPP, ScaFi, and an experimental implementation of \ac{XC} in Scala.
%
\Cref{chap:background} discusses the background information necessary for understanding the thesis, including discussions on the Exchange Calculus and Scala 3, covering topics such as the type system, explicit nulls, and multiversal equality.
%
\Cref{chap:analysis} conducts a comprehensive analysis, beginning with a detailed examination of the requirements, followed by the analysis of the current state of the ScaFi framework, from which this project originates.
%
\Cref{chap:design} outlines the design process, starting with the study of four proposed prototypes, and culminating in the final design of the core DSL and associated components such as the engine and the simulator.
%
\Cref{chap:implementation} focuses on the implementation details, covering aspects such as the implementation of the \ac{XC} operational semantics, the build system, and integration with the Alchemist simulator.
%
\Cref{chap:evaluation} presents the evaluation methodology and results, including unit tests, acceptance tests, continuous integration, and techniques employed for code quality and maintainability.
%
Finally, \Cref{chap:conclusion-and-future-work} concludes the thesis and provides insights into future work and potential extensions or improvements.

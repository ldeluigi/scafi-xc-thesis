% ! TeX root = ../thesis-main.tex
%----------------------------------------------------------------------------------------
\chapter{Introduction}
\label{chap:introduction}
%----------------------------------------------------------------------------------------

The importance of \acp{CAS} engineering is increasing along with the growing prevalence of large-scale cyber-physical systems, driven by the already pervasive \ac{IoT} and edge computing trends~\cite{collective,pervasive}.
%
\acp{CAS} are a particular subcategory of situated, distributed systems in which a collection of individuals, also called agents, exhibits a non-chaotic behavior characterized by \textit{self-*} properties, such as self-organization, self-healing, and self-configuration.
%
Many of the self-* properties cannot be derived from an individual perspective confined to the behavior of a single agent, but rather they are \textit{emergent} from the complex and dynamic network of interactions within the system and with the environment.
%
As a consequence, obtaining such properties requires a holistic approach to the design and programming of \acp{CAS}, which is not straightforward to achieve with traditional software engineering techniques.

Topologically, \acp{CAS} can be considered a subset of \acp{MAS}, and the programming of their behavior as a whole can be referred to as \textit{Macroprogramming}~\cite{macroprogramming-state-of-the-art}.
%
In the context of macroprogramming, a prominent paradigm is that of \textit{aggregate computing}, where a single program, called the aggregate program, defines the overall behavior of a network of devices or agents~\cite{macroprogramming-state-of-the-art}.
%
Aggregate computing provides benefits to development productivity thanks to four main factors~\cite{scafi}: the \textit{macro-level stance}, which abstracts over low-level details about the individual behavior of agents and their communication media, the \textit{compositionality}, promoting the creation of complex behavior by combining simpler ones, the \textit{formality}, allowing theoretical analyses and formal verification of its properties, and the \textit{practicality}, thanks to the availability of tools supporting programming and simulation of \acp{CAS}.

Among these tools, an in-depth analysis is dedicated to the \textit{ScaFi}, an aggregate programming framework that comprises an internal \ac{DSL} written in Scala 2 with supporting components for simulation, visualization, and execution of aggregate systems, based on the \ac{FC} formal language and computational model~\cite{scafi}.
%
Internal \acp{DSL} are distinguished from external \acp{DSL} by the fact that they are embedded in a host language, such as Scala, and that they exploit the flexibility of their host's syntax to resemble a different language even though they are implemented as libraries.

Recently, a new formal language and computational model called \ac{XC} has been proposed, extending the expressiveness of \ac{FC} while simplifying its set of primitive constructs~\cite{xc}.
%
In the meantime, Scala 2 has been succeeded by Scala 3, which introduces a relevant set of new features and improvements over its predecessor.
%
These two novelties have promoted the development of a new ScaFi, entirely redesigned to be formally based on \ac{XC} and to make the best use of its new host language, Scala 3.
%
That project is the main subject of this thesis.
%
Named \quotes{\this}, it has the ambition to \textit{scale}, meaning to grow with the demand of its user without losing its qualities, such as expressiveness, reusability, maintainability, readability, and performance.


\paragraph{Structure of the Thesis} This thesis first introduces the state of the art in aggregate computing tools and languages.
%
Then, it presents a more in-depth dissertation on \ac{XC} and Scala 3, which are the main theoretical and practical foundations of \this, respectively.
%
In the analysis chapter, the requirements of the project are discussed, followed by the analysis of the current state of the ScaFi framework, from which this project originates.
%
In the design chapter, the architecture of the \texttt{core} module of \this is presented, along with the design choices that have been made for the supportive modules such as \texttt{simulator} and \texttt{tests}.
%
Implementation details are then explained in the following chapter, along with experimental and exploratory developments.
%
The evaluation chapter presents results from the testing and validation of the project, including techniques employed for code quality and maintainability.
%
Finally, the thesis concludes with a discussion of the results and the future work that can be done to improve the project.

% ! TeX root = ../thesis-main.tex
%----------------------------------------------------------------------------------------
\chapter{Implementation}
\label{chap:implementation}
%----------------------------------------------------------------------------------------

This chapter documents the implementation details of the models and libraries designed, as well as additional tools and extensions developed as research experiments and proof of concepts.
%
In particular, the chapter covers the implementation of an experimental \texttt{FoldhoodLibrary}, that demonstrates the expressiveness of the \this design by implementing an \ac{API} for \texttt{foldhood} and \texttt{foldhoodPlus} similar to the original ScaFi, and the prototype of a different implementation of the \texttt{AggregateFoundation} trait, which adds compile time assertions on the user code to prevent common mistakes and improve the quality of aggregate programs, at the expense of more complicated signatures of library methods.
%
The chapter also covers the integration of \this with the Alchemist simulator, which enables graphical and more realistic simulations, as well as additional proof of the functionality of \this.

\section{Implementation of the XC operational semantics} \label{chap:implementation->sec:xc-ops}

The implementation of the operational semantics as described in paper\cite{xc} follows the design of \cref{chap:design->sec:final-dsl->subsec:exchange-calculus-semantics-design} by defining a concrete class that inherits from \texttt{ExchangeCalculusSemantics}.
%
Given that the same class serves as context for the execution of aggregate programs' rounds, following the engine design of \cref{chap:design->sec:final-dsl->subsec:engine}, it implements the \texttt{Context} interface too.
%
The name \texttt{BasicExchangeCalculusContext} because it is meant to provide a simple yet readable and reliable implementation, without pursuing premature optimizations or additional features.
%
A more advanced implementation could be developed in the future, maybe specifically tailored to some destination platform or network implementation.
%
In order to maximize the reusability of its code, the logic and behavior that compose the operational semantics has been broken down into several mixin layers, with their dependencies declared through self-type annotations and abstract members.
%
These mixin layers have been organized into two packages based on their reusability: \texttt{context.common} with the most general and reusable mixins, and \texttt{context.exchange} with the mixins that are specific to the exchange calculus, as shown in \cref{fig:context-mixins-common,fig:context-mixins-exchange}.

\begin{figure}
    \centering
    \caption{Exchange Calculus context mixins: \ac{UML} diagram of the mixin layers in package \texttt{common}, stripped of transitive dependencies.}
    \label{fig:context-mixins-common}
    \bigskip
    \resizebox{\linewidth}{!}{
        \input{diagrams/context-mixins/Context Mixins - Common.latex}
    }
\end{figure}

\begin{figure}
    \centering
    \caption{Exchange Calculus context mixins: \ac{UML} diagram of the mixin layers in package \texttt{exchange}, stripped of transitive dependencies.}
    \label{fig:context-mixins-exchange}
    \bigskip
    \resizebox{\linewidth}{!}{
        \input{diagrams/context-mixins/Context Mixins - Exchange.latex}
    }
\end{figure}

TODO explain how the stuff works

\section{The build system}

Following the requirements listed in \cref{chap:analysis->sec:requirement-analysis}, the chosen build system for the project is \ac{SBT}, in particular version \texttt{1.9.8}.
%
The build tool has been customized with the following plugins:
\begin{itemize}
    \item \texttt{sbt-scalafix} to lint the code with \textit{scalafix}, further explained in \cref{chap:evaluation->sec:code-style};
    \item \texttt{sbt-scalafmt} to lint the code with \textit{scalafmt}, further explained in \cref{chap:evaluation->sec:code-style};
    \item \texttt{sbt-scalajs} and \texttt{bt-scalajs-crossproject} to cross-build the project for \textit{JavaScript} with \textit{scala-js};
    \item \texttt{sbt-scala-native} and \texttt{sbt-scala-native-crossproject} to cross-build the project for \textit{native} with \textit{scala-native}.
\end{itemize}
%
In addition to that, the Dotty compiler has been customized with flags that enhance the quality of the code, such as the aforementioned \textit{explicit nulls} and \textit{multiversal equality}, but also enforcement for indentation over curly braces style, warnings as errors, safe initialization checks, warnings on value discards, and more.

\section{The \texttt{FoldhoodLibrary}}

As a proof of concept of the expressiveness of the \this design, an experimental library has been developed, called \texttt{FoldhoodLibrary}, which provides an \ac{API} for the \texttt{foldhood} and \texttt{foldhoodPlus} constructs as defined in the original ScaFi library.
%
The library works for any aggregate context that supports the \texttt{FieldCalculusSyntax}, and implements \texttt{foldhood}, \texttt{foldhoodPlus}, \texttt{nbr}, and \texttt{nbrRange} for contexts that also support \texttt{DistanceSensor}.
%
The resulting \ac{API} can be seen used in \cref{lst:foldhood-library-usage},
where \texttt{nbr} is not the same as the one defined in \texttt{FielCalculusLibrary} but has a different signature, that takes a lazy expression of type \texttt{=> T} and returns a \texttt{T}.
%
When evaluating a foldhood, the expression is evaluated as is and the values passed to \texttt{nbr} are recorded and returned in order, then shared with neighbors.
%
Then, for each aligned neighbor, the same expression is re-evaluated, this time substituting the \texttt{nbr} return values with the ones coming from neighbors, in the right order to match the expression.
%
If the context implements the \texttt{DistanceSensor} trait, \texttt{nbrRange} can be invoked to return the distance from the current node to the neighbor evaluated in the foldhood.
%
The only difference between \texttt{foldhood} and \texttt{foldhoodPlus} is that the former does not include the expression value of the current node in the folding result, while the latter does.
%
The example of \cref{lst:foldhood-library-usage} demonstrates that \texttt{nbr} can be used with arguments of any type, as long as they type check in the foldhood expression.

\lstinputlisting[float, language=Scala, caption={Usage example of the \texttt{FoldhoodLibrary}.}, label={lst:foldhood-library-usage}]{listings/foldhood-usage.scala}

\section{Context-based constraints on the aggregate foundation trait}

TODO write

\section{Integration with the Alchemist simulator}

TODO write

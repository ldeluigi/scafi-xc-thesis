@article{aggregate-programming,
  author  = {Beal, Jacob and Pianini, Danilo and Viroli, Mirko},
  journal = {Computer},
  title   = {Aggregate Programming for the Internet of Things},
  year    = {2015},
  volume  = {48},
  number  = {9},
  pages   = {22-30},
  doi     = {10.1109/MC.2015.261},
  issn    = {1558-0814},
  month   = {Sep.}
}

@article{alchemist,
  doi       = {10.1057/jos.2012.27},
  url       = {https://doi.org/10.1057/jos.2012.27},
  year      = {2013},
  month     = aug,
  publisher = {Informa {UK} Limited},
  volume    = {7},
  number    = {3},
  pages     = {202--215},
  author    = {D Pianini and S Montagna and M Viroli},
  title     = {Chemical-oriented simulation of computational systems with {ALCHEMIST}},
  journal   = {Journal of Simulation}
}

@article{collective,
  author   = {Abowd, Gregory D.},
  journal  = {Computer},
  title    = {Beyond Weiser: From Ubiquitous to Collective Computing},
  year     = {2016},
  volume   = {49},
  number   = {1},
  pages    = {17-23},
  keywords = {Ubiquitous computing;Internet of things;Collaboration;History;Computer industry;Wearable computing;computing;collective computing;ubiquitous computing;history of computing;Internet of Things;IoT;wearables;technology;human-computer interaction},
  doi      = {10.1109/MC.2016.22}
}

@article{density-independence-in-fc,
  author     = {Viroli, Mirko and Audrito, Giorgio and Beal, Jacob and Damiani, Ferruccio and Pianini, Danilo},
  title      = {Engineering Resilient Collective Adaptive Systems by Self-Stabilisation},
  year       = {2018},
  issue_date = {April 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {28},
  number     = {2},
  issn       = {1049-3301},
  url        = {https://doi.org/10.1145/3177774},
  doi        = {10.1145/3177774},
  abstract   = {Collective adaptive systems are an emerging class of networked computational systems particularly suited for application domains such as smart cities, complex sensor networks, and the Internet of Things. These systems tend to feature large-scale, heterogeneity of communication model (including opportunistic peer-to-peer wireless interaction) and require inherent self-adaptiveness properties to address unforeseen changes in operating conditions. In this context, it is extremely difficult (if not seemingly intractable) to engineer reusable pieces of distributed behaviour to make them provably correct and smoothly composable.Building on the field calculus, a computational model (and associated toolchain) capturing the notion of aggregate network-level computation, we address this problem with an engineering methodology coupling formal theory and computer simulation. On the one hand, functional properties are addressed by identifying the largest-to-date field calculus fragment generating self-stabilising behaviour, guaranteed to eventually attain a correct and stable final state despite any transient perturbation in state or topology and including highly reusable building blocks for information spreading, aggregation, and time evolution. On the other hand, dynamical properties are addressed by simulation, empirically evaluating the different performances that can be obtained by switching between implementations of building blocks with provably equivalent functional properties. Overall, our methodology sheds light on how to identify core building blocks of collective behaviour and how to select implementations that improve system performance while leaving overall system function and resiliency properties unchanged.},
  journal    = {ACM Trans. Model. Comput. Simul.},
  month      = {mar},
  articleno  = {16},
  numpages   = {28},
  keywords   = {Aggregate computing, collective adaptive systems, distributed algorithms, field calculus, self-stabilisation, simulation and modeling}
}

@inproceedings{dot,
  title    = {Dependent Object Types},
  author   = {Amin, Nada and Moors, Adriaan and Odersky, Martin},
  year     = {2012},
  abstract = {We propose a new type-theoretic foundation of Scala and  languages like it: the Dependent Object Types (DOT)  calculus. DOT models Scala’s path-dependent types,  abstract type members and its mixture of nominal and  structural typing through the use of reﬁnement types. The  core formalism makes no attempt to model inheritance and  mixin composition. DOT normalizes Scala’s type system by  unifying the constructs for type members and by providing  classical intersection and union types which simplify  greatest lower bound and least upper bound computations. In  this paper, we present the DOT calculus, both formally and  informally. We also discuss our work-in-progress to prove  typesafety of the calculus.},
  url      = {http://infoscience.epfl.ch/record/183030}
}

@inproceedings{fc,
  author    = {Viroli, Mirko and Damiani, Ferruccio and Beal, Jacob},
  year      = {2013},
  month     = {09},
  pages     = {114-128},
  title     = {A Calculus of Computational Fields},
  volume    = {393},
  isbn      = {978-3-642-45363-2},
  journal   = {Communications in Computer and Information Science},
  doi       = {10.1007/978-3-642-45364-9_11},
  booktitle = {Advances in Service-Oriented and Cloud Computing: Workshops of ESOCC 2013, M{\'a}laga, Spain, September 11-13, 2013, Revised Selected Papers 2}
}

@inproceedings{fcpp,
  author    = {Audrito, Giorgio},
  booktitle = {2020 IEEE International Conference on Autonomic Computing and Self-Organizing Systems (ACSOS)},
  title     = {FCPP: an efficient and extensible Field Calculus framework},
  year      = {2020},
  volume    = {},
  number    = {},
  pages     = {153-159},
  abstract  = {The Field Calculus is a promising language for the self-organisation of distributed devices, allowing to express on a high level of abstraction complex distributed algorithms with robust behaviour guarantees. This language has been argued to be fruitfully applicable to many different contexts: wireless sensor networks, internet of things, self-organising edge, fog or cloud computing scenarios, and simulations of such. However, existing implementations of this language rely on the Java Virtual Machine and have an high performance overhead, impairing their usability in contexts where performance is critical (cloud) or computational resources are tightly bounded (WSN/IoT).In this paper we present FCPP, a novel implementation of the Field Calculus as a C++ library. The library is built as a component-based system, in order to be easily extensible to fit different contexts. Furthermore, it leverages C++ template patterns to allow compile-time optimisation and minimal performance overhead, and enables fine-grained parallelism for scalability in self-organising cloud applications. A case study of an edge simulation shows the performance improvement compared to existing Field Calculus implementations, while preserving the same level of abstraction. This translates to a significant speed-up in the development process of distributed algorithms, paving the way towards application scenarios for which existing tools are unsuitable: microcontroller systems and self-organising cloud.},
  keywords  = {Aggregates;Calculus;C++ languages;Tools;Programming;Cloud computing;Libraries;edge computing;aggregate computing;programming languages;field calculus;toolchains},
  doi       = {10.1109/ACSOS49614.2020.00037},
  issn      = {},
  month     = {Aug}
}


@article{from-dc-to-fc-and-ap,
  title    = {From distributed coordination to field calculus and aggregate computing},
  journal  = {Journal of Logical and Algebraic Methods in Programming},
  volume   = {109},
  pages    = {100486},
  year     = {2019},
  issn     = {2352-2208},
  doi      = {https://doi.org/10.1016/j.jlamp.2019.100486},
  url      = {https://www.sciencedirect.com/science/article/pii/S235222081930032X},
  author   = {Mirko Viroli and Jacob Beal and Ferruccio Damiani and Giorgio Audrito and Roberto Casadei and Danilo Pianini},
  keywords = {Distributed systems, Aggregate computing, Field calculus, Spatial computing}
}

@article{hofc,
  author     = {Audrito, Giorgio and Viroli, Mirko and Damiani, Ferruccio and Pianini, Danilo and Beal, Jacob},
  title      = {A Higher-Order Calculus of Computational Fields},
  year       = {2019},
  issue_date = {January 2019},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {20},
  number     = {1},
  issn       = {1529-3785},
  url        = {https://doi.org/10.1145/3285956},
  doi        = {10.1145/3285956},
  journal    = {ACM Trans. Comput. Logic},
  month      = {jan},
  articleno  = {5},
  numpages   = {55}
}

@article{macroprogramming-state-of-the-art,
  author     = {Roberto Casadei},
  title      = {Macroprogramming: Concepts, State of the Art, and Opportunities of Macroscopic Behaviour Modelling},
  journal    = {CoRR},
  volume     = {abs/2201.03473},
  year       = {2022},
  url        = {https://arxiv.org/abs/2201.03473},
  eprinttype = {arXiv},
  eprint     = {2201.03473},
  timestamp  = {Thu, 20 Jan 2022 14:21:35 +0100},
  biburl     = {https://dblp.org/rec/journals/corr/abs-2201-03473.bib},
  bibsource  = {dblp computer science bibliography, https://dblp.org}
}

@article{pervasive,
  author   = {Satyanarayanan, M.},
  journal  = {IEEE Personal Communications},
  title    = {Pervasive computing: vision and challenges},
  year     = {2001},
  volume   = {8},
  number   = {4},
  pages    = {10-17},
  keywords = {Pervasive computing;Mobile computing;Scalability;Space technology;Wireless application protocol;Access protocols;TCPIP;Transcoding;Resource management;Computer vision},
  doi      = {10.1109/98.943998}
}

@inproceedings{protelis,
  author    = {Pianini, Danilo and Viroli, Mirko and Beal, Jacob},
  title     = {Protelis: practical aggregate programming},
  year      = {2015},
  isbn      = {9781450331968},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2695664.2695913},
  doi       = {10.1145/2695664.2695913},
  booktitle = {Proceedings of the 30th Annual ACM Symposium on Applied Computing},
  pages     = {1846-1853},
  numpages  = {8},
  keywords  = {aggregate programming, alchemist, computational field, coordination, field calculus},
  location  = {Salamanca, Spain},
  series    = {SAC '15}
}

@inproceedings{real-time-error-tolerance-in-fc,
  author    = {Audrito, Giorgio and Damiani, Ferruccio and Viroli, Mirko and Bini, Enrico},
  booktitle = {2018 IEEE Real-Time Systems Symposium (RTSS)},
  title     = {Distributed Real-Time Shortest-Paths Computations with the Field Calculus},
  year      = {2018},
  volume    = {},
  number    = {},
  pages     = {23-34},
  keywords  = {Calculus;Aggregates;Programming;Computational modeling;Real-time systems;Sensors;Wireless sensor networks;aggregate computing;field calculus;shortest path;IoT;distributed systems},
  doi       = {10.1109/RTSS.2018.00013}
}

@article{scafi,
  title   = {ScaFi: A Scala DSL and Toolkit for Aggregate Programming},
  journal = {SoftwareX},
  volume  = {20},
  pages   = {101248},
  year    = {2022},
  issn    = {2352-7110},
  doi     = {https://doi.org/10.1016/j.softx.2022.101248},
  url     = {https://www.sciencedirect.com/science/article/pii/S2352711022001662},
  author  = {Roberto Casadei and Mirko Viroli and Gianluca Aguzzi and Danilo Pianini}
}

@phdthesis{scafi-thesis,
  author   = {Roberto Casadei},
  title    = {Aggregate Programming in Scala: a Core Library and Actor-Based Platform for Distributed Computational Fields},
  url      = {http://amslaurea.unibo.it/10341/},
  keywords = {aggregate-programming field-calculus distributed-framework actors self-organization Scala},
  school   = {Alma Mater Studiorum - Università di Bologna},
  year     = {2016}
}

@inproceedings{scafi-with-alchemist,
  author    = {Casadei, Roberto and Pianini, Danilo and Viroli, Mirko},
  booktitle = {2016 Federated Conference on Computer Science and Information Systems (FedCSIS)},
  title     = {Simulating large-scale aggregate MASs with alchemist and scala},
  year      = {2016},
  volume    = {},
  number    = {},
  pages     = {1495-1504},
  abstract  = {Recent works in the context of large-scale adaptive systems, such as those based on opportunistic IoT-based applications, promote aggregate programming, a development approach for distributed systems in which the collectivity of devices is directly targeted, instead of individual ones. This makes the resulting behaviour highly insensitive to network size, density, and topology, and as such, intrinsically robust to failures and changes to working conditions (e.g., location of computational load, communication technology, and computational infrastructure). Most specifically, we argue that aggregate programming is particularly suitable for building models and simulations of complex large-scale reactive MASs. Accordingly, in this paper we describe SCAFI (Scala Fields), a Scala-based API and DSL for aggregate programming, and its integration with the ALCHEMIST simulator, and usage scenarios in the context of smart mobility.},
  keywords  = {Aggregates;Programming;Calculus;Context;Libraries;DSL;Robustness;aggregate programming;Scala;DSL;simulation},
  doi       = {},
  issn      = {},
  month     = {Sep.}
}

@inproceedings{scala-js,
  author    = {Doeraene, S\'{e}bastien},
  title     = {Cross-platform language design in Scala.js (keynote)},
  year      = {2018},
  isbn      = {9781450358361},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3241653.3266230},
  doi       = {10.1145/3241653.3266230},
  abstract  = {Have you ever wondered what is the secret sauce of Scala.js? What defines Scala.js, above all else, is the overarching will to make it cross-platform. A cross-platform language is both portable—most source code cross-compiles and behaves the same way on multiple platforms—and interoperable—code written in that language can interoperate with other languages on the target platforms. Most multi-platform languages are designed with one of those two properties in mind, and only address the other one as an afterthought. This results in poor integration, difficulty to write portable code, or even the impossibility to use some platform-specific libraries. This talk shows how Scala.js was designed as a cross-platform language. We show how portability and interoperability drive every design decision, from which language feature to include to performance considerations. We state a criteria of completeness for interoperability, and show how Scala.js satisfies it (with the exception of one JavaScript language feature, still work-in-progress). We give insights about what features are critical for portability, and which ones can be relaxed in the name of performance. In particular, we stress the importance of the ecosystem of libraries: existing assumptions in the ecosystem can force the language designer into reproducing behaviors of Scala/JVM, even when they are accidental. As a practical exercise, we study the main language changes that made it into Scala.js 1.x wrt. 0.6.x—as well as possible future developments—and how they fit into the cross-platform language design methodology.},
  booktitle = {Proceedings of the 9th ACM SIGPLAN International Symposium on Scala},
  pages     = {1},
  numpages  = {1},
  keywords  = {language design, SCALA},
  location  = {St. Louis, MO, USA},
  series    = {Scala 2018}
}


@inproceedings{scala-patterns,
  author    = {Odersky, Martin and Zenger, Matthias},
  title     = {Scalable component abstractions},
  year      = {2005},
  isbn      = {1595930310},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1094811.1094815},
  doi       = {10.1145/1094811.1094815},
  abstract  = {We identify three programming language abstractions for the construction of reusable components: abstract type members, explicit selftypes, and modular mixin composition. Together, these abstractions enable us to transform an arbitrary assembly of static program parts with hard references between them into a system of reusable components. The transformation maintains the structure of the original system. We demonstrate this approach in two case studies, a subject/observer framework and a compiler front-end.},
  booktitle = {Proceedings of the 20th Annual ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications},
  pages     = {41-57},
  numpages  = {17},
  keywords  = {mixins, components, classes, abstract types, Scala},
  location  = {San Diego, CA, USA},
  series    = {OOPSLA '05}
}

@article{scala-popularity,
  title     = {Programming language impact on the development of distributed systems},
  author    = {Ghosh, Debasish and Sheehy, Justin and Thorup, Kresten Krab and Vinoski, Steve},
  journal   = {Journal of Internet Services and Applications},
  volume    = {3},
  number    = {1},
  pages     = {23--30},
  year      = {2012},
  publisher = {Springer}
}

@article{self-stabilisation-in-fc,
  author     = {Viroli, Mirko and Audrito, Giorgio and Beal, Jacob and Damiani, Ferruccio and Pianini, Danilo},
  title      = {Engineering Resilient Collective Adaptive Systems by Self-Stabilisation},
  year       = {2018},
  issue_date = {April 2018},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {28},
  number     = {2},
  issn       = {1049-3301},
  url        = {https://doi.org/10.1145/3177774},
  doi        = {10.1145/3177774},
  abstract   = {Collective adaptive systems are an emerging class of networked computational systems particularly suited for application domains such as smart cities, complex sensor networks, and the Internet of Things. These systems tend to feature large-scale, heterogeneity of communication model (including opportunistic peer-to-peer wireless interaction) and require inherent self-adaptiveness properties to address unforeseen changes in operating conditions. In this context, it is extremely difficult (if not seemingly intractable) to engineer reusable pieces of distributed behaviour to make them provably correct and smoothly composable.Building on the field calculus, a computational model (and associated toolchain) capturing the notion of aggregate network-level computation, we address this problem with an engineering methodology coupling formal theory and computer simulation. On the one hand, functional properties are addressed by identifying the largest-to-date field calculus fragment generating self-stabilising behaviour, guaranteed to eventually attain a correct and stable final state despite any transient perturbation in state or topology and including highly reusable building blocks for information spreading, aggregation, and time evolution. On the other hand, dynamical properties are addressed by simulation, empirically evaluating the different performances that can be obtained by switching between implementations of building blocks with provably equivalent functional properties. Overall, our methodology sheds light on how to identify core building blocks of collective behaviour and how to select implementations that improve system performance while leaving overall system function and resiliency properties unchanged.},
  journal    = {ACM Trans. Model. Comput. Simul.},
  month      = {mar},
  articleno  = {16},
  numpages   = {28},
  keywords   = {Aggregate computing, collective adaptive systems, distributed algorithms, field calculus, self-stabilisation, simulation and modeling}
}

@article{service-oriented-design,
  author     = {Odersky, Martin and Zenger, Matthias},
  title      = {Scalable component abstractions},
  year       = {2005},
  issue_date = {October 2005},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {40},
  number     = {10},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1103845.1094815},
  doi        = {10.1145/1103845.1094815},
  abstract   = {We identify three programming language abstractions for the construction of reusable components: abstract type members, explicit selftypes, and modular mixin composition. Together, these abstractions enable us to transform an arbitrary assembly of static program parts with hard references between them into a system of reusable components. The transformation maintains the structure of the original system. We demonstrate this approach in two case studies, a subject/observer framework and a compiler front-end.},
  journal    = {SIGPLAN Not.},
  month      = {oct},
  pages      = {41–57},
  numpages   = {17},
  keywords   = {mixins, components, classes, abstract types, Scala}
}

@inproceedings{share-operator,
  author    = {"Audrito, Giorgio and Beal, Jacob and Damiani, Ferruccio and Pianini, Danilo and Viroli, Mirko"},
  editor    = {"Riis Nielson, Hanne and Tuosto, Emilio"},
  title     = {"The share Operator for Field-Based Coordination"},
  booktitle = {"Coordination Models and Languages"},
  year      = {"2019"},
  publisher = {"Springer International Publishing"},
  address   = {"Cham"},
  pages     = {"54--71"}
}

@inproceedings{traits,
  abstract    = {Despite the undisputed prominence of inheritance as
                 the fundamental reuse mechanism in object-oriented
                 programming languages, the main variants --- single
                 inheritance, multiple inheritance, and mixin
                 inheritance --- all suffer from conceptual and
                 practical problems. In the first part of this paper,
                 we identify and illustrate these problems. We then
                 present traits, a simple compositional model for
                 structuring object-oriented programs. A trait is
                 essentially a group of pure methods that serves as a
                 building block for classes and is a primitive unit
                 of code reuse. In this model, classes are composed
                 from a set of traits by specifying glue code that
                 connects the traits together and accesses the
                 necessary state. We demonstrate how traits overcome
                 the problems arising from the different variants of
                 inheritance, we discuss how traits can be
                 implemented effectively, and we summarize our
                 experience applying traits to refactor an existing
                 class hierarchy.},
  acceptnum   = {18},
  accepttotal = {88},
  address     = {Berlin Heidelberg},
  annote      = {internationalconference topconference},
  author      = {Nathanael Sch\"arli and St\'ephane Ducasse and Oscar Nierstrasz and Andrew P. Black},
  booktitle   = {Proceedings of European Conference on Object-Oriented Programming (ECOOP'03)},
  cvs         = {TraitsECOOP2003},
  doi         = {10.1007/b11832},
  isbn        = {978-3-540-40531-3},
  keywords    = {snf03 scg-pub scg-none jb03 scg-traits stefPub schaerli onhindex(297)},
  location    = {Darmstadt, Germany},
  misc        = {acceptance rate: 18/88 = 20\%},
  month       = jul,
  pages       = {248--274},
  publisher   = {Springer Verlag},
  series      = {LNCS},
  title       = {Traits: Composable Units of Behavior},
  url         = {http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf},
  volume      = {2743},
  year        = {2003},
  bdsk-url-1  = {http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf},
  bdsk-url-2  = {http://dx.doi.org/10.1007/b11832}
}

@article{xc,
  title   = {The eXchange Calculus (XC): A functional programming language design for distributed collective systems},
  journal = {Journal of Systems and Software},
  volume  = {210},
  pages   = {111976},
  year    = {2024},
  issn    = {0164-1212},
  doi     = {https://doi.org/10.1016/j.jss.2024.111976},
  url     = {https://www.sciencedirect.com/science/article/pii/S0164121224000190},
  author  = {Giorgio Audrito and Roberto Casadei and Ferruccio Damiani and Guido Salvaneschi and Mirko Viroli}
}

@inproceedings{xc-experiment-with-scafi,
  author    = {Audrito, Giorgio and Casadei, Roberto and Damiani, Ferruccio and Salvaneschi, Guido and Viroli, Mirko},
  title     = {Functional Programming for Distributed Systems with XC},
  booktitle = {36th European Conference on Object-Oriented Programming (ECOOP 2022)},
  pages     = {20:1--20:28},
  series    = {Leibniz International Proceedings in Informatics (LIPIcs)},
  isbn      = {978-3-95977-225-9},
  issn      = {1868-8969},
  year      = {2022},
  volume    = {222},
  editor    = {Ali, Karim and Vitek, Jan},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address   = {Dagstuhl, Germany},
  url       = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2022.20},
  urn       = {urn:nbn:de:0030-drops-162486},
  doi       = {10.4230/LIPIcs.ECOOP.2022.20},
  annote    = {Keywords: Core calculus, operational semantics, type soundness, Scala DSL}
}

@misc{xc-experiment-with-scafi-code,
  author    = {Roberto Casadei},
  title     = {scafi/artifact-2021-ecoop-xc: v1.2},
  month     = may,
  year      = 2022,
  publisher = {Zenodo},
  version   = {v1.2},
  doi       = {10.5281/zenodo.6538810},
  url       = {https://doi.org/10.5281/zenodo.6538810}
}

@book{xtext,
  title     = {Implementing domain-specific languages with Xtext and Xtend},
  author    = {Bettini, Lorenzo},
  year      = {2016},
  publisher = {Packt Publishing Ltd}
}

